//@version=5
strategy("Hermes SIMPLE Strategy", overlay=false, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=100, pyramiding=1, calc_on_every_tick=false, calc_on_order_fills=false, process_orders_on_close=true)

// ============================================================================
// ðŸ“Š OPTIMIZER PARAMETERS - Update these with optimizer results
// ============================================================================
// These match the SIMPLE_MODE optimizer output columns exactly
// Current values are DEFAULTS (manual testing: 150,000% with macro filter OFF)

// ALMA Periods
min_short_period = input.int(10, "Min Short Period", minval=5, maxval=150, group="ALMA")
max_short_period = input.int(50, "Max Short Period", minval=5, maxval=150, group="ALMA")
long_period = input.int(150, "Long Period", minval=100, maxval=400, group="ALMA")

// ADX for dynamic short period
adx_period = input.int(14, "ADX Period", minval=2, maxval=50, group="ALMA", 
     tooltip="ADX period for dynamic short-term ALMA adjustment")

// ALMA Settings (fixed for all conditions)
alma_offset = input.float(0.8, "ALMA Offset", minval=0.3, maxval=1, step=0.05, group="ALMA")
alma_sigma = input.float(3.5, "ALMA Sigma", minval=2.0, maxval=10.0, step=1.0, group="ALMA")
alma_min_separation = input.float(0.0001, "Min ALMA Separation", minval=0.0, maxval=0.01, step=0.0001, group="ALMA",
     tooltip="Minimum distance between ALMA lines required for valid signal (prevents whipsaw on tight crosses)")

// Entry Filters
momentum_lookback_long = input.int(1, "Momentum Lookback (Long)", minval=0, maxval=15, group="Entry Filters",
     tooltip="Lookback for momentum confirmation when opening positions (0 = disabled)")
momentum_lookback_short = input.int(15, "Momentum Lookback (Short)", minval=0, maxval=15, group="Entry Filters",
     tooltip="Lookback for momentum confirmation when closing positions (0 = disabled)")
slow_ema_rising_lookback = input.int(0, "Slow EMA Rising Lookback", minval=0, maxval=15, group="Entry Filters",
     tooltip="Slow EMA must be rising over this period (0 = disabled)")

// Macro Filter
macro_ema_period = input.int(0, "Macro EMA Period", minval=0, maxval=300, group="Entry Filters",
     tooltip="Macro trend EMA period (0 = disabled, was previously controlled by use_macro_filter toggle)")

// Display
show_debug = input.bool(true, "Show Debug Info", group="Display")

// ============================================================================
// CALCULATIONS
// ============================================================================

// Determine which filters are enabled (0 = disabled)
use_momentum_long = momentum_lookback_long > 0
use_momentum_short = momentum_lookback_short > 0
use_macro_filter = macro_ema_period > 0
use_slow_ema_rising = slow_ema_rising_lookback > 0

// Log returns for ALMA
daily_return = na(close[1]) ? 1.0 : close / close[1]
log_return = math.log(daily_return)

// ============================================================================
// CUSTOM ALMA FUNCTION (for dynamic period)
// ============================================================================
f_alma(series float src, series int period, simple float offset, simple float sigma) =>
    m = offset * (period - 1)
    s = period / sigma
    
    sum = 0.0
    norm = 0.0
    for i = 0 to period - 1
        w = math.exp(-1 * math.pow(i - m, 2) / (2 * math.pow(s, 2)))
        sum := sum + w * src[i]
        norm := norm + w
    
    sum / norm

// ============================================================================
// ADX CALCULATION (for dynamic short period)
// ============================================================================
// Calculate True Range and Directional Movement
tr = math.max(high - low, math.max(math.abs(high - close[1]), math.abs(low - close[1])))
up_move = high - high[1]
down_move = low[1] - low
plus_dm = (up_move > down_move and up_move > 0) ? up_move : 0.0
minus_dm = (down_move > up_move and down_move > 0) ? down_move : 0.0

// Smooth using Wilder's smoothing (RMA)
smoothed_tr = ta.rma(tr, adx_period)
smoothed_plus_dm = ta.rma(plus_dm, adx_period)
smoothed_minus_dm = ta.rma(minus_dm, adx_period)

// Calculate Directional Indicators
plus_di = 100 * smoothed_plus_dm / smoothed_tr
minus_di = 100 * smoothed_minus_dm / smoothed_tr

// Calculate DX and ADX
dx = 100 * math.abs(plus_di - minus_di) / (plus_di + minus_di)
adx_value = ta.rma(dx, adx_period)

// ============================================================================
// DYNAMIC SHORT PERIOD BASED ON ADX
// ============================================================================
// Normalize ADX (typically ranges 0-100, but often stays 0-50)
// Map ADX linearly: higher ADX = longer period
adx_normalized = math.min(adx_value / 50.0, 1.0)  // Cap at 1.0
dynamic_short_period = math.round(min_short_period + (max_short_period - min_short_period) * adx_normalized)

// ALMA signals
long_term = ta.alma(log_return, long_period, alma_offset, alma_sigma)
short_term = f_alma(log_return, dynamic_short_period, alma_offset, alma_sigma)
baseline = long_term

// Macro filter (only calculate if enabled)
macro_ema = use_macro_filter ? ta.ema(close, macro_ema_period) : close
in_bull_market = use_macro_filter ? close > macro_ema : true

// ============================================================================
// ENTRY SIGNALS
// ============================================================================

bullish_state = short_term > baseline
bearish_state = short_term < baseline

// ALMA separation check - ensure meaningful cross with minimum distance
alma_separation = math.abs(short_term - baseline)
valid_separation = alma_separation >= alma_min_separation

// Momentum filters for long entries (only calculate if enabled)
is_highest_close = use_momentum_long ? 
     (high >= ta.highest(high[1], momentum_lookback_long) and close >= ta.highest(math.max(open[1], close[1]), momentum_lookback_long)) : 
     true

// Momentum filters for short/exit signals (only calculate if enabled)
is_lowest_low = use_momentum_short ? 
     (low <= ta.lowest(low[1], momentum_lookback_short) and close <= ta.lowest(math.min(open[1], close[1]), momentum_lookback_short)) : 
     true

// Slow EMA rising (only calculate if enabled)
slow_ema_rising = use_slow_ema_rising ? 
     macro_ema > macro_ema[slow_ema_rising_lookback] : 
     true

// Build buy signal
buy_signal = bullish_state and valid_separation

if use_momentum_long
    buy_signal := buy_signal and is_highest_close

if use_macro_filter
    buy_signal := buy_signal and in_bull_market

if use_slow_ema_rising
    buy_signal := buy_signal and slow_ema_rising

// Build sell signal
sell_signal = bearish_state and valid_separation
if use_momentum_short
    sell_signal := sell_signal and is_lowest_low

// ============================================================================
// POSITION TRACKING
// ============================================================================

in_position = strategy.position_size > 0

// ============================================================================
// EXIT LOGIC (Process BEFORE entries to avoid conflicts)
// ============================================================================

if in_position and sell_signal
    strategy.close("Long")

// ============================================================================
// ENTRY (Process AFTER exits)
// ============================================================================

if buy_signal and not in_position
    strategy.entry("Long", strategy.long)

// ============================================================================
// PLOTTING
// ============================================================================

plot(short_term, title="Short-Term Signal", color=color.blue, linewidth=2)
plot(baseline, title="Long-Term Baseline", color=color.black, linewidth=2)
plot(0, title="Zero", color=color.gray, style=plot.style_line, linewidth=1)

bgcolor(in_position ? color.new(color.green, 95) : na, title="In Position")

var label filter_mode_label = na
label_y_position = ta.highest(short_term, 100)

if barstate.islast
    // Build status string for enabled filters
    filters_status = ""
    if use_momentum_long
        filters_status := filters_status + " Mâ†‘"
    if use_macro_filter
        filters_status := filters_status + " MACRO"
    if use_slow_ema_rising
        filters_status := filters_status + " EMAâ†‘"
    
    label_text = "ðŸ“Š SIMPLE ALMA" + (filters_status == "" ? " (No Filters)" : " -" + filters_status)
    label_color = color.new(color.green, 80)

    if na(filter_mode_label)
        filter_mode_label := label.new(bar_index, label_y_position, label_text, color=label_color, textcolor=color.white, style=label.style_label_down, size=size.small)
    else
        label.set_xy(filter_mode_label, bar_index, label_y_position)
        label.set_text(filter_mode_label, label_text)
        label.set_color(filter_mode_label, label_color)

plotshape(buy_signal and not in_position, "Buy", shape.triangleup, location.bottom, color.green, size=size.normal, text="BUY")
plotshape(sell_signal and in_position, "Sell", shape.triangledown, location.top, color.red, size=size.normal, text="SELL")

blocked_by_momentum = bullish_state and not is_highest_close and use_momentum_long and not in_position
plotshape(show_debug ? blocked_by_momentum : na, "Blocked", shape.xcross, location.bottom, color.orange, size=size.tiny, text="M")

// Debug: Plot ADX and dynamic period (optional - can be toggled off)
plot(show_debug ? adx_value : na, "ADX", color=color.purple, display=display.none)
plot(show_debug ? dynamic_short_period : na, "Dynamic Short Period", color=color.orange, display=display.none)
