//@version=6
strategy("Hermes Strategy", overlay=false, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=100, pyramiding=20)

// ============================================================================
// INPUTS - OPTIMIZED PARAMETERS (Labels match optimizer output)
// ============================================================================
// â­ From optimizer: Short Period = 48
shortPeriod = input.int(48, "Short Period (OPTIMIZER)", minval=5, maxval=200, group="Core ALMA", tooltip="Optimized: 48")
// â­ From optimizer: Long Period = 137
longPeriod = input.int(137, "Long Period (OPTIMIZER)", minval=50, maxval=500, group="Core ALMA", tooltip="Optimized: 137")

// DEPRECATED - Not used by optimizer (kept for backward compatibility)
almaOffset = input.float(0.95, "ALMA Offset (UNUSED)", minval=0.0, maxval=1.0, step=0.01, group="Legacy")
almaSigma = input.float(4.0, "ALMA Sigma (UNUSED)", minval=1.0, maxval=15.0, step=0.1, group="Legacy")

// â­ From optimizer: Momentum Lookback = 3
momentumLookback = input.int(3, "Momentum Lookback (OPTIMIZER)", minval=1, maxval=20, group="Filters", tooltip="Optimized: 3")
useMomentumFilters = input.bool(true, "Use Momentum Filters", group="Filters")

// â­ From optimizer: Macro EMA Period = 60
useMacroFilter = input.bool(true, "Use Macro Bull Market Filter", group="Filters")
macroEmaPeriod = input.int(60, "Macro EMA Period (OPTIMIZER)", minval=50, maxval=400, group="Filters", tooltip="Optimized: 60 (was 150 default)")

// â­ From optimizer: Fast HMA Period = 10
fastHmaPeriodInput = input.int(10, "Fast HMA Period (OPTIMIZER)", minval=5, maxval=200, group="Price Structure", tooltip="Optimized: 10 (was 30 default)")
// â­ From optimizer: Slow EMA Period = 74
slowEmaPeriodInput = input.int(74, "Slow EMA Period (OPTIMIZER)", minval=20, maxval=300, group="Price Structure", tooltip="Optimized: 74 (was 80 default)")

// â­ From optimizer: Slow EMA Rising Lookback = 18
slowEmaRisingLookback = input.int(18, "Slow EMA Rising Lookback (OPTIMIZER)", minval=1, maxval=50, group="Filters", tooltip="Optimized: 18 (was 3 default)")

// â­ From optimizer: Profit Period Scale = 0.20
profitPeriodScaleFactor = input.float(0.20, "Profit Period Scale (OPTIMIZER)", minval=0.0, maxval=0.2, step=0.01, group="Exit Logic", tooltip="Optimized: 0.20 (was 0.02 default)")

// Advanced Trend Detection Parameters
// â­ From optimizer: Trend Analysis Period = 50
trendAnalysisPeriod = input.int(50, "Trend Analysis Period (OPTIMIZER)", minval=10, maxval=200, group="Trend Detection", tooltip="Optimized: 50")
// â­ From optimizer: Trend Threshold = 0.27
trendThreshold = input.float(0.27, "Trend Threshold (OPTIMIZER)", minval=0.0, maxval=1.0, step=0.01, group="Trend Detection", tooltip="Optimized: 0.27 (was 0.60 default - LOW threshold = mostly trending)")

// Trend Component Weights
// â­ From optimizer: Weight Efficiency = 0.63, Weight R-Squared = 0.74 (normalized to 0.46/0.54)
weightEfficiency = input.float(0.46, "Weight Efficiency (OPTIMIZER)", minval=0.0, maxval=1.0, step=0.01, group="Trend Detection", tooltip="Optimized: 0.46 (normalized from 0.63)")
weightRSquared = input.float(0.54, "Weight R-Squared (OPTIMIZER)", minval=0.0, maxval=1.0, step=0.01, group="Trend Detection", tooltip="Optimized: 0.54 (normalized from 0.74)")

// ALMA Dynamic Parameters - RANGING (tight exits)
// â­ From optimizer: Ranging ALMA Offset = 0.97
baseShortPeriod = input.int(48, "Short Period â†’ USE TOP INPUT", minval=10, maxval=200, group="Dynamic ALMA (Ranging)")
baseLongPeriod = input.int(137, "Long Period â†’ USE TOP INPUT", minval=50, maxval=500, group="Dynamic ALMA (Ranging)")
// â­ From optimizer: Ranging ALMA Offset = 0.97
baseAlmaOffset = input.float(0.97, "Ranging ALMA Offset (OPTIMIZER)", minval=0.80, maxval=0.99, step=0.01, group="Dynamic ALMA (Ranging)", tooltip="Optimized: 0.97 (was 0.95)")
// â­ From optimizer: Ranging ALMA Sigma = 3.0
baseAlmaSigma = input.float(3.0, "Ranging ALMA Sigma (OPTIMIZER)", minval=1.0, maxval=10.0, step=0.5, group="Dynamic ALMA (Ranging)", tooltip="Optimized: 3.0 (was 4.0)")

// ALMA Dynamic Parameters - TRENDING (loose exits)
targetShortPeriodMultiplier = input.float(2.5, "Target Short Period Multiplier", minval=1.5, maxval=4.0, step=0.1, group="Dynamic ALMA (Trending)")
targetLongPeriodMultiplier = input.float(1.8, "Target Long Period Multiplier", minval=1.2, maxval=3.0, step=0.1, group="Dynamic ALMA (Trending)")
// â­ From optimizer: Trending ALMA Offset = 0.92
targetAlmaOffset = input.float(0.92, "Trending ALMA Offset (OPTIMIZER)", minval=0.50, maxval=0.99, step=0.01, group="Dynamic ALMA (Trending)", tooltip="Optimized: 0.92 (was 0.99)")
// â­ From optimizer: Trending ALMA Sigma = 9.0
targetAlmaSigma = input.float(9.0, "Trending ALMA Sigma (OPTIMIZER)", minval=3.0, maxval=18.0, step=0.5, group="Dynamic ALMA (Trending)", tooltip="Optimized: 9.0 (was 8.0)")

// Room to Breathe Weights (how much to loosen exits as trade develops)
weightProfit = input.float(0.40, "Weight: Profit %", minval=0.0, maxval=1.0, step=0.05, tooltip="Weight for profit earned (has it made money?)")
weightTrendSustained = input.float(0.30, "Weight: Trend Sustained", minval=0.0, maxval=1.0, step=0.05, tooltip="Weight for sustained trend strength")
weightPriceStructure = input.float(0.20, "Weight: Price Structure", minval=0.0, maxval=1.0, step=0.05, tooltip="Weight for bullish price structure confirmation")
weightTrendGrowth = input.float(0.10, "Weight: Trend Growth", minval=0.0, maxval=1.0, step=0.05, tooltip="Weight for trend strengthening since entry")

profitTargetPct = input.float(0.50, "Profit Target for Max Room", minval=0.20, maxval=2.0, step=0.10, tooltip="Profit % needed for maximum 'room to breathe' (default 50%)")
trendGrowthTarget = input.float(0.30, "Trend Growth Target", minval=0.10, maxval=0.50, step=0.05, tooltip="Trend strength increase for max score (default +0.30)")

showDebugInfo = input.bool(true, "Debug Info")

// ============================================================================
// CORE CALCULATIONS
// ============================================================================
// Returns for ALMA smoothing
dailyReturn = na(close[1]) ? 1.0 : close / close[1]
logReturn = math.log(dailyReturn)

// Macro regime filter
macroEma = ta.ema(close, macroEmaPeriod)
inBullMarket = close > macroEma

// ============================================================================
// ADVANCED TREND DETECTION FUNCTIONS
// ============================================================================

// Function: Calculate Efficiency Ratio (directional movement / total movement)
// Returns: 0-1 where 1 = perfectly efficient trend
// Used in KAMA indicator - measures how efficiently price moves in one direction
f_efficiencyRatio(src, period) =>
    change = math.abs(src - src[period])

    volatility = 0.0
    for i = 1 to period
        volatility := volatility + math.abs(src[i-1] - src[i])

    efficiency = volatility > 0 ? change / volatility : 0.0
    math.min(1.0, efficiency)

// Function: Linear Regression R-Squared
// Returns: 0-1 where higher = more linear = trending
// Measures how well price fits a straight line (trend quality)
f_rSquared(src, period) =>
    sumX = 0.0
    sumY = 0.0
    sumXY = 0.0
    sumX2 = 0.0
    sumY2 = 0.0

    for i = 0 to period - 1
        x = float(i)
        y = src[i]
        sumX := sumX + x
        sumY := sumY + y
        sumXY := sumXY + (x * y)
        sumX2 := sumX2 + (x * x)
        sumY2 := sumY2 + (y * y)

    n = float(period)

    // Pearson correlation coefficient
    numerator = (n * sumXY) - (sumX * sumY)
    denominator = math.sqrt(((n * sumX2) - (sumX * sumX)) * ((n * sumY2) - (sumY * sumY)))

    correlation = denominator > 0 ? numerator / denominator : 0.0

    // R-squared
    rSquared = math.pow(correlation, 2)
    math.min(1.0, math.max(0.0, rSquared))

// ============================================================================
// COMPOSITE TREND STRENGTH CALCULATION
// ============================================================================

// Calculate the 2 core trend metrics
efficiencyRatio = f_efficiencyRatio(close, trendAnalysisPeriod)
rSquared = f_rSquared(close, trendAnalysisPeriod)

// Both metrics are already normalized to 0-1 where 1 = strong trend
efficiencyScore = efficiencyRatio  // 0-1: directional efficiency
rSquaredScore = rSquared  // 0-1: trend linearity/quality

// Weighted composite score (2-factor model)
// Normalize weights to sum to 1.0 for consistency
weightSum = weightEfficiency + weightRSquared
w_efficiency = weightSum > 0 ? weightEfficiency / weightSum : 0.70
w_rSquared = weightSum > 0 ? weightRSquared / weightSum : 0.30

// Composite trend strength: weighted combination
// High efficiency + High RÂ² = strong, clean trend
// High efficiency + Low RÂ² = directional but choppy
// Low efficiency = ranging regardless of RÂ²
trendStrength = (w_efficiency * efficiencyScore) + (w_rSquared * rSquaredScore)

// Clamp to 0-1 (should already be in range, but safety check)
trendStrength := math.min(1.0, math.max(0.0, trendStrength))

// Smooth the trend strength to avoid whipsaws
smoothedTrendStrength = ta.ema(trendStrength, 5)

// Boolean: Are we in a trending market?
isTrendingMarket = smoothedTrendStrength > trendThreshold

// ============================================================================
// PRICE STRUCTURE (needed for room-to-breathe calculation)
// ============================================================================

fastHmaPeriod = math.max(1, fastHmaPeriodInput)
slowEmaPeriod = math.max(fastHmaPeriod + 1, slowEmaPeriodInput)
fastHma = ta.hma(close, fastHmaPeriod)
slowEma = ta.ema(close, slowEmaPeriod)

// ============================================================================
// DYNAMIC ALMA PARAMETERS - "ROOM TO BREATHE" SYSTEM
// ============================================================================

// Check if in position (needed for room-to-breathe calculation)
inPosition = strategy.position_size > 0
positionEntryPrice = strategy.position_avg_price

// Track trend strength at entry
var float entryTrendStrength = 0.0
var int entryBarIndex = 0

// Track profit history for maturity calculation
var array<float> profitHistory = array.new<float>(0)
var float peakProfit = 0.0
var float maturityScore = 0.0

// === ROOM TO BREATHE CALCULATION ===
// Determines how much to loosen exits based on trade development

var float roomToBreathe = 0.0

if inPosition
    // === MATURITY GATE (Anti-Curve-Fitting) ===
    // Prevents premature loosening from lucky spikes using RELATIVE metrics

    profitPercent = (close - positionEntryPrice) / positionEntryPrice
    barsInPosition = bar_index - entryBarIndex

    // Update profit history (rolling window of last 20 bars or position length)
    array.push(profitHistory, profitPercent)
    if array.size(profitHistory) > 20
        array.shift(profitHistory)

    // Update peak profit
    if profitPercent > peakProfit
        peakProfit := profitPercent

    // Component 1: Time Maturity (logarithmic scaling, diminishing returns)
    // Reaches ~0.5 at 25 bars, ~0.71 at 50 bars, ~1.0 at 100 bars
    timeMaturity = math.min(1.0, math.sqrt(barsInPosition) / math.sqrt(100))

    // Component 2: Profit Consistency (Sharpe-like: avg/stddev)
    // Stable growth (low variance) scores higher than erratic spikes
    avgProfit = array.avg(profitHistory)
    stdProfit = array.stdev(profitHistory)
    consistencyRatio = stdProfit > 0 ? math.abs(avgProfit) / stdProfit : 0.0
    // Normalize: good consistency ratio is 0.5-2.0, cap at 2.0
    consistencyScore = math.min(1.0, consistencyRatio / 2.0)

    // Component 3: Drawdown Resilience (hasn't given back gains)
    // Mature trends maintain their highs, immature ones spike and crash
    drawdownFromPeak = peakProfit > 0 ? (peakProfit - profitPercent) / peakProfit : 0.0
    resilienceScore = math.max(0.0, 1.0 - drawdownFromPeak)

    // Composite Maturity Score (equal weights, 0-1 scale)
    maturityScore := (timeMaturity + consistencyScore + resilienceScore) / 3.0

    // Factor 1: Profit earned (0-1 normalized, GATED BY MATURITY)
    rawProfitScore = math.min(1.0, math.max(0.0, profitPercent / profitTargetPct))
    profitScore = rawProfitScore * maturityScore  // KEY: Lucky spikes get discounted

    // Factor 2: Trend strength sustained over position lifetime
    avgTrendStrengthSinceEntry = barsInPosition > 0 ? ta.sma(smoothedTrendStrength, barsInPosition) : smoothedTrendStrength
    trendSustainedScore = math.min(1.0, math.max(0.0, avgTrendStrengthSinceEntry))

    // Factor 3: Price structure confirms trend (GRADUATED SCORING)
    // Full credit: both HMA and EMA above entry
    // Partial credit: one of the two above entry
    // No credit: both below entry
    hmaAboveEntry = fastHma > positionEntryPrice
    emaAboveEntry = slowEma > positionEntryPrice
    hmaAboveEma = fastHma > slowEma

    // Graduated scoring: 0.0 to 1.0 based on how many conditions are met
    structureConditionsMet = (hmaAboveEntry ? 0.33 : 0.0) + (emaAboveEntry ? 0.33 : 0.0) + (hmaAboveEma ? 0.34 : 0.0)
    priceStructureScore = structureConditionsMet

    // Factor 4: Trend has STRENGTHENED (not just maintained)
    trendDevelopment = math.max(0.0, smoothedTrendStrength - entryTrendStrength)
    trendGrowthScore = math.min(1.0, math.max(0.0, trendDevelopment / trendGrowthTarget))

    // Normalize weights
    weightSum = weightProfit + weightTrendSustained + weightPriceStructure + weightTrendGrowth
    w_profit = weightSum > 0 ? weightProfit / weightSum : 0.40
    w_sustained = weightSum > 0 ? weightTrendSustained / weightSum : 0.30
    w_structure = weightSum > 0 ? weightPriceStructure / weightSum : 0.20
    w_growth = weightSum > 0 ? weightTrendGrowth / weightSum : 0.10

    // Composite "room to breathe" score
    roomToBreathe := (w_profit * profitScore) +
                     (w_sustained * trendSustainedScore) +
                     (w_structure * priceStructureScore) +
                     (w_growth * trendGrowthScore)

    // Clamp 0-1
    roomToBreathe := math.min(1.0, math.max(0.0, roomToBreathe))
else
    roomToBreathe := 0.0
    maturityScore := 0.0

// === CALCULATE DYNAMIC ALMA PARAMETERS ===
// Interpolate periods based on "room to breathe"
targetShortPeriod = int(baseShortPeriod * targetShortPeriodMultiplier)
targetLongPeriod = int(baseLongPeriod * targetLongPeriodMultiplier)

dynamicShortPeriod = int(baseShortPeriod + (roomToBreathe * (targetShortPeriod - baseShortPeriod)))
dynamicLongPeriod = int(baseLongPeriod + (roomToBreathe * (targetLongPeriod - baseLongPeriod)))

// Interpolate offset and sigma
dynamicOffset = baseAlmaOffset + (roomToBreathe * (targetAlmaOffset - baseAlmaOffset))
dynamicSigma = baseAlmaSigma + (roomToBreathe * (targetAlmaSigma - baseAlmaSigma))

// === CALCULATE ALMA WITH DYNAMIC PARAMETERS ===
// Pine Script v6 requires "simple" types, so calculate base + target and blend
shortTermBase = ta.alma(logReturn, baseShortPeriod, baseAlmaOffset, baseAlmaSigma)
shortTermTarget = ta.alma(logReturn, targetShortPeriod, targetAlmaOffset, targetAlmaSigma)
longTermBase = ta.alma(logReturn, baseLongPeriod, baseAlmaOffset, baseAlmaSigma)
longTermTarget = ta.alma(logReturn, targetLongPeriod, targetAlmaOffset, targetAlmaSigma)

// Interpolate ALMA results based on room to breathe
shortTerm = shortTermBase + (roomToBreathe * (shortTermTarget - shortTermBase))
longTerm = longTermBase + (roomToBreathe * (longTermTarget - longTermBase))
baseline = longTerm

// ============================================================================
// SIGNAL LOGIC
// ============================================================================
bullishState = shortTerm > baseline
bearishState = shortTerm < baseline

// Pre-calculate adaptive ALMA for ranging exits (always calculate for consistency)
// Note: This old profit-scaling logic is now redundant since room-to-breathe handles this
// But keep it for backward compatibility with ranging exits
profitPercentOld = inPosition ? (close - positionEntryPrice) / positionEntryPrice * 100 : 0.0
periodMultiplierOld = 1.0 + (math.max(0, profitPercentOld) * profitPeriodScaleFactor)
adaptiveShortPeriod = int(baseShortPeriod * math.min(periodMultiplierOld, 3.0))
adaptiveShortTerm = ta.alma(logReturn, adaptiveShortPeriod, baseAlmaOffset, baseAlmaSigma)

// Pre-calculate highest/lowest values for momentum filters (v6 requirement)
highestClosePrev = ta.highest(close[1], momentumLookback)
highestHighPrev = ta.highest(high[1], momentumLookback)
lowestLowPrev = ta.lowest(low[1], momentumLookback)
lowestClosePrev = ta.lowest(close[1], momentumLookback)

isHighestClose = close >= highestClosePrev and high >= highestHighPrev
isLowestLow = low <= lowestLowPrev and close <= lowestClosePrev

slowEmaRising = slowEma > slowEma[slowEmaRisingLookback]

// Price structure checks (calculated globally for consistency)
trendCrossUnder = ta.crossunder(fastHma, slowEma)

baseBuySignal = bullishState
baseSellSignal = bearishState

buySignal = baseBuySignal
sellSignal = baseSellSignal

if useMomentumFilters
    buySignal := buySignal and isHighestClose
    sellSignal := sellSignal and isLowestLow

if useMacroFilter
    buySignal := buySignal and inBullMarket

buySignal := buySignal and slowEmaRising

// ============================================================================
// REGIME DETECTION & EXIT LOGIC
// ============================================================================

// Track which regime we're in using sophisticated trend detection
var bool trendingRegime = false

// Reset regime when not in position
if not inPosition
    trendingRegime := false
    entryTrendStrength := 0.0
    entryBarIndex := 0
    peakProfit := 0.0
    array.clear(profitHistory)

// Entry
if buySignal and not inPosition
    strategy.entry("Long", strategy.long)
    trendingRegime := false
    entryTrendStrength := smoothedTrendStrength  // Store trend strength at entry
    entryBarIndex := bar_index  // Store entry bar for position duration calculation

// Exit trigger flags for plotting
var trendingExitTrigger = false
var rangingExitTrigger = false

if inPosition
    trendingExitTrigger := false
    rangingExitTrigger := false

    // ========================================================================
    // SOPHISTICATED TRENDING REGIME DETECTION
    // ========================================================================
    // Multi-factor trending confirmation:
    // 1. Global trend strength indicator says we're trending
    // 2. Price structure confirms (fast HMA > slow EMA, both above entry)
    // 3. Trend strength has increased or maintained since entry

    priceStructureBullish = fastHma > slowEma and slowEma > positionEntryPrice and fastHma > positionEntryPrice
    trendStrengthMaintained = smoothedTrendStrength >= (entryTrendStrength * 0.8)  // Allow 20% degradation

    trendingSetup = isTrendingMarket and priceStructureBullish and trendStrengthMaintained

    // Regime transition logic with hysteresis to avoid whipsaws
    if trendingSetup and smoothedTrendStrength > trendThreshold
        trendingRegime := true
    else if smoothedTrendStrength < (trendThreshold * 0.7) or not priceStructureBullish
        // Exit trending regime if trend significantly weakens or price structure breaks
        trendingRegime := false

    // ========================================================================
    // TRENDING REGIME EXIT LOGIC
    // ========================================================================
    sellMomentumOk = not useMomentumFilters or isLowestLow

    // Close beneath entry price - exit immediately without waiting for cross
    closeBelowEntry = close < positionEntryPrice

    // Normal trending exit: HMA crosses under EMA with momentum confirmation
    normalTrendingExit = (trendCrossUnder and sellMomentumOk) ? true : false

    trendingExit = (trendingRegime and (closeBelowEntry or normalTrendingExit)) ? true : false

    // ========================================================================
    // RANGING REGIME EXIT LOGIC
    // ========================================================================
    // Use pre-calculated adaptive ALMA (calculated globally for consistency)
    adaptiveBearishState = adaptiveShortTerm < baseline
    adaptiveSellSignal = adaptiveBearishState
    if useMomentumFilters
        adaptiveSellSignal := adaptiveSellSignal and isLowestLow

    rangingExit = (not trendingRegime and adaptiveSellSignal) ? true : false

    // ========================================================================
    // EXECUTE EXIT
    // ========================================================================
    exitSignal = trendingExit or rangingExit

    if exitSignal
        if trendingExit
            trendingExitTrigger := true
            rangingExitTrigger := false
        else
            trendingExitTrigger := false
            rangingExitTrigger := true
        strategy.close("Long")
        trendingRegime := false
else
    trendingExitTrigger := false
    rangingExitTrigger := false

// ============================================================================
// PLOTTING
// ============================================================================

plot(shortTerm, title="Short-Term Signal", color=color.blue, linewidth=2)
plot(baseline, title="Long-Term Baseline", color=color.black, linewidth=2)
plot(0, title="Zero", color=color.gray, style=plot.style_line, linewidth=1)

bgcolor(inPosition ? color.new(color.green, 95) : na, title="In Position")

var label filterModeLabel = na
labelYPosition = ta.highest(shortTerm, 100)

if barstate.islast
    labelText = "ðŸ“Š ALMA FILTER"
    labelColor = color.new(color.blue, 80)
    if na(filterModeLabel)
        filterModeLabel := label.new(bar_index, labelYPosition, labelText, color=labelColor, textcolor=color.white, style=label.style_label_down, size=size.small)
    else
        label.set_xy(filterModeLabel, bar_index, labelYPosition)
        label.set_text(filterModeLabel, labelText)
        label.set_color(filterModeLabel, labelColor)

plotshape(buySignal and not inPosition, "Buy Executed", shape.triangleup, location.bottom, color.green, size=size.normal, text="BUY")
plotshape(trendingExitTrigger, "Trending Exit", shape.triangledown, location.top, color.red, size=size.normal, text="TREND")
plotshape(rangingExitTrigger, "Ranging Exit", shape.triangledown, location.top, color.new(color.orange, 30), size=size.normal, text="RANGE")

blockedByMomentum = bullishState and not isHighestClose and useMomentumFilters and not inPosition
showBlockedByMomentum = showDebugInfo and blockedByMomentum
plotshape(showBlockedByMomentum, "Blocked by Momentum", shape.xcross, location.bottom, color.orange, size=size.tiny, text="M")

// ============================================================================
// ADVANCED TREND STRENGTH VISUALIZATION
// ============================================================================

// Calculate trend strength visualization (always calculate, conditionally display)
almaRange = ta.highest(shortTerm, 200) - ta.lowest(shortTerm, 200)
almaMid = (ta.highest(shortTerm, 200) + ta.lowest(shortTerm, 200)) / 2

// Map trend strength (0-1) to ALMA range
trendStrengthPlot = almaMid + (smoothedTrendStrength - 0.5) * almaRange * 0.3
thresholdPlot = almaMid + (trendThreshold - 0.5) * almaRange * 0.3

// Color: green when trending, red when ranging
trendColor = smoothedTrendStrength > trendThreshold ? color.new(color.green, 60) : color.new(color.red, 60)

// Plot trend strength (only visible when debug enabled)
plot(showDebugInfo ? trendStrengthPlot : na, title="Trend Strength", color=trendColor, linewidth=1, style=plot.style_line)
plot(showDebugInfo ? thresholdPlot : na, title="Trend Threshold", color=color.new(color.purple, 70), linewidth=1, style=plot.style_circles)

// Background coloring: light green for trending, light red for ranging
bgcolor(showDebugInfo and isTrendingMarket ? color.new(color.green, 97) : showDebugInfo ? color.new(color.red, 97) : na, title="Market Regime")

// Plot individual component scores (optional - can be commented out if too noisy)
// Uncomment these lines to see individual metrics
// efficiencyPlot = almaMid + (efficiencyScore - 0.5) * almaRange * 0.3
// rSquaredPlot = almaMid + (rSquaredScore - 0.5) * almaRange * 0.3
// plot(showDebugInfo ? efficiencyPlot : na, title="Efficiency Score", color=color.new(color.orange, 80), linewidth=1)
// plot(showDebugInfo ? rSquaredPlot : na, title="RÂ² Score", color=color.new(color.purple, 80), linewidth=1)

// ============================================================================
// "ROOM TO BREATHE" VISUALIZATION
// ============================================================================

// Plot room to breathe score (shows how loose/tight exits are)
roomToBreathePlot = almaMid + (roomToBreathe - 0.5) * almaRange * 0.3

// Color: gradient from tight (red) to loose (green)
roomColor = roomToBreathe < 0.33 ? color.new(color.red, 50) : roomToBreathe < 0.67 ? color.new(color.orange, 50) : color.new(color.green, 50)

plot(showDebugInfo and inPosition ? roomToBreathePlot : na, title="Room to Breathe", color=roomColor, linewidth=2, style=plot.style_line)

// Plot maturity score (shows trade maturity: time + consistency + resilience)
maturityPlot = almaMid + (maturityScore - 0.5) * almaRange * 0.3

// Color: gradient from immature (orange) to mature (blue)
maturityColor = maturityScore < 0.33 ? color.new(color.orange, 60) : maturityScore < 0.67 ? color.new(color.yellow, 60) : color.new(color.blue, 60)

plot(showDebugInfo and inPosition ? maturityPlot : na, title="Maturity Score", color=maturityColor, linewidth=1, style=plot.style_circles)

// Optional: Plot dynamic period values to see how they change
// plot(showDebugInfo and inPosition ? dynamicShortPeriod : na, title="Dynamic Short Period", color=color.new(color.blue, 70), linewidth=1)
// plot(showDebugInfo and inPosition ? dynamicLongPeriod : na, title="Dynamic Long Period", color=color.new(color.purple, 70), linewidth=1)
